<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<title>GAP (dev) - Chapter 2: The GAP kernel programming</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap2"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap1_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap3_mj.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap2.html">[MathJax off]</a></p>
<p><a id="X810D56CE7BC6031F" name="X810D56CE7BC6031F"></a></p>
<div class="ChapSects"><a href="chap2_mj.html#X810D56CE7BC6031F">2 <span class="Heading">The <strong class="pkg">GAP</strong> kernel programming</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2_mj.html#X8071E6CA7A9CF5DF">2.1 <span class="Heading">Overview of the <strong class="pkg">GAP</strong> kernel</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2_mj.html#X7F9BD7A37B142C23">2.2 <span class="Heading">"Hello World" example</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2_mj.html#X78D70F927B947A2C">2.3 <span class="Heading">Structure of the <strong class="pkg">GAP</strong> kernel</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2_mj.html#X86BA4BA17AA4F56C">2.4 <span class="Heading">Garbage collection in <strong class="pkg">GAP</strong></span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X86E038D8796AECA3">2.4-1 <span class="Heading"><strong class="pkg">GASMAN</strong></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7AA6E6517ED276FA">2.4-2 <span class="Heading"><strong class="pkg">GASMAN</strong> Interface</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7C1EFEEB8071E0A2">2.4-3 <span class="Heading">The GASMAN Interface for Weak Pointer Objects</span></a>
</span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2_mj.html#X815C2D007A090300">2.5 <span class="Heading">Interfaces</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2_mj.html#X849901607E91AC92">2.6 <span class="Heading">Objects and API</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7B314E837FD109B1">2.6-1 <span class="Heading">Immediate Integers and FFEs</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X87FF26F4878230FB">2.6-2 <span class="Heading">Arithmetics</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X86FA580F8055B274">2.6-3 <span class="Heading">Functions</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7B256AE5780F140A">2.6-4 <span class="Heading">Lists</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X789D77787E3527D4">2.6-5 <span class="Heading">Data objects</span></a>
</span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2_mj.html#X7A547AB487DA5FA9">2.7 <span class="Heading">Rules of Kernel Programming</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X861B9EB587F6B238">2.7-1 <span class="Heading">Three golden rules</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X8055D4158291EAA2">2.7-2 <span class="Heading">Common kernel traps</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7FC1A0FA7B0E8554">2.7-3 <span class="Heading">One More Bit of GASMAN interface</span></a>
</span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2_mj.html#X82DBFB18873C8E8F">2.8 <span class="Heading">The <strong class="pkg">GAP</strong> compiler</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7AFA67497FA81DCD">2.8-1 <span class="Heading">Compiling <strong class="pkg">GAP</strong> Code</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7FBB45C17D3F3B0B">2.8-2 <span class="Heading">Suitability for Compilation</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X844D3126800839DE">2.8-3 <span class="Heading">Compiling Library Code</span></a>
</span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2_mj.html#X7D9044767BEB1523">2.9 <span class="Heading">Global Variables</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7D9044767BEB1523">2.9-1 <span class="Heading">Global variables</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7A106F327F75851A">2.9-2 <span class="Heading">Tracking global variables</span></a>
</span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2_mj.html#X7B6775AC8609D5AB">2.10 <span class="Heading">The Kernel Module Structure and interface</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X82E5407283B16176">2.10-1 <span class="Heading">The Kernel Module Structure</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X875A1DC186FEC3C5">2.10-2 <span class="Heading">The Kernel Module Interface</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7FBC8CDB82C7A500">2.10-3 <span class="Heading">Sequences of Events</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X80CAC88A7E9561E3">2.10-4 <span class="Heading">Saving a Workspace</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X809F94777E699351">2.10-5 <span class="Heading">Excerpts from InitKernel from integer.c</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7EA36574819CE9AD">2.10-6 <span class="Heading">Commentary</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X802173687AD2C3FD">2.10-7 <span class="Heading">Other Similar Functions</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X781C432386ED9C00">2.10-8 <span class="Heading">Importing from the Library</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X797D02CD7AC39FE6">2.10-9 <span class="Heading">InitKernel</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2_mj.html#X7FDA1F307BC45E44">2.10-10 <span class="Heading">initLibrary and postRestore</span></a>
</span>
</div></div>
</div>

<h3>2 <span class="Heading">The <strong class="pkg">GAP</strong> kernel programming</span></h3>

<p><a id="X8071E6CA7A9CF5DF" name="X8071E6CA7A9CF5DF"></a></p>

<h4>2.1 <span class="Heading">Overview of the <strong class="pkg">GAP</strong> kernel</span></h4>

<p>The <strong class="pkg">GAP</strong> kernel consists of more than 150000 lines of <strong class="pkg">C</strong> code that:</p>


<ul>
<li><p>provides the run-time environment and user interface;</p>

</li>
<li><p>interprets the <strong class="pkg">GAP</strong> language;</p>

</li>
<li><p>performs arithmetic operations with basic types of objects;</p>

</li>
<li><p>speeds up some time-critical operations.</p>

</li>
</ul>
<p>The <strong class="pkg">GAP</strong> kernel code mainly falls into the four main categories:</p>

<ol>
<li><p>Implementations for basic data types and structures (integers, permutations, finite field elements, etc.), which has to be in the kernel for the maximal efficiency.</p>

</li>
<li><p>Low level access methods for data objects (lists, ranges, records, etc.).</p>

</li>
<li><p>Various methods for handling complex <strong class="pkg">GAP</strong> objects in component and positional representation from the kernel.</p>

</li>
<li><p><strong class="pkg">GAP</strong> foundations such as <strong class="pkg">GAP</strong> language, garbage collector (in what follows - GC), etc.</p>

</li>
</ol>
<p>The <strong class="pkg">GAP</strong> kernel programming has four levels of sofistication:</p>

<ol>
<li><p>The simplest form of kernel programming is to add new kernel functions for manipulating existing data types.</p>

</li>
<li><p>Using the "data object" type to add new binary data structures to the kernel.</p>

</li>
<li><p>Adding new basic (primitive) data types, such as, for example, <em>Floats</em>.</p>

</li>
<li><p>Modifying the foundations, for example, changing the syntax of the <strong class="pkg">GAP</strong> language.</p>

</li>
</ol>
<p>We will cover only first two levels here, while adding new basic data types or modifying the foundations are outside the scope of this manual.</p>

<p><a id="X7F9BD7A37B142C23" name="X7F9BD7A37B142C23"></a></p>

<h4>2.2 <span class="Heading">"Hello World" example</span></h4>

<p>On the <strong class="pkg">GAP</strong> level, the kernel functionality may be acessed via kernel functions. You can recognise such functions because they will be displayed as compiled code in the <strong class="pkg">GAP</strong> session:</p>


<div class="example"><pre>

gap&gt; Display(TYPE_OBJ);
function ( obj )
    &lt;&lt;kernel code&gt;&gt; from src/objects.c:TYPE_OBJ
end

</pre></div>

<p>Let us demonstrate how to add a kernel function that will print "Hello World!". Such function has no arguments and returns nothing. To add it, we need to perform three basic steps:</p>

<ol>
<li><p>Create the <strong class="pkg">C</strong> handler, adding to the file <code class="file">string.c</code> (this file contains the functions which mainly deal with strings) the <strong class="pkg">C</strong> code doing the actual job (see the function <code class="code">Pr</code> to print formatted output in the file <code class="file">scanner.c</code> ):</p>


<div class="example"><pre>

static Obj FuncHELLO_WORLD(Obj self)
{
    Pr("Hello World!\n", 0, 0);
    return 0;
}

</pre></div>

<p>This code should be placed somewhere in the file <code class="file">string.c</code> before specifying <code class="code">GvarFuncs</code>.</p>

</li>
<li><p>In the same file <code class="file">string.c</code> find the list of functions to export called <code class="code">GvarFuncs</code> and add to this list a table entry for <code class="code">HELLO_WORLD</code></p>


<div class="example"><pre>

GVAR_FUNC(HELLO_WORLD, 0, ""),

</pre></div>

<p>containing respectively the string specifying the name of the function at the <strong class="pkg">GAP</strong> level, the number of arguments, the string with the description of arguments, corresponding <strong class="pkg">C</strong> handler and the string ("cookie") specifying the location of this handler (see definition of the structure <code class="code">StructGVarFunc</code> in the file <code class="file">system.h</code> ).</p>

</li>
<li><p>Compile the <strong class="pkg">GAP</strong> kernel, and now <code class="code">HELLO_WORLD();</code> will work.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HELLO_WORLD();</span>
Hello World!

</pre></div>

</li>
</ol>
<p><a id="X78D70F927B947A2C" name="X78D70F927B947A2C"></a></p>

<h4>2.3 <span class="Heading">Structure of the <strong class="pkg">GAP</strong> kernel</span></h4>

<p>The following picture is based on the scheme that Martin Schönert drew in 1995 and displays the structure of the <strong class="pkg">GAP</strong> kernel: <img src="bigpic.jpg" align="left" /> The 2nd line of the scheme, the "interpreter/coder/expressions/statements/vars/funcs/calls/compiler" level is essentially the <strong class="pkg">GAP</strong> runtime system. It takes in <strong class="pkg">GAP</strong> code and (possibly after parsing and storing it) executes it by calling functions from the modules below. The GAP compiler is (a sort of) a drop in replacement for this, and there could be others, such as a bytecode generator/interpreter.</p>

<p>In the region within the thick lines the kernel code sees the same world as <strong class="pkg">GAP</strong> code: it sees objects (including functions), with automatic management of memory occupied by them. The only difference is that the kernel code can look, if necessary, inside the binary content of the objects.</p>

<p>Unevaluated expressions or fragments of the <strong class="pkg">GAP</strong> code never appear in this region and below it. Therefore, there are only a few ways to pass control back from that level:</p>


<ul>
<li><p>Calling a <strong class="pkg">GAP</strong> function;</p>

</li>
<li><p>Entering a break loop;</p>

</li>
<li><p>Reading a file.</p>

</li>
</ul>
<p><a id="X86BA4BA17AA4F56C" name="X86BA4BA17AA4F56C"></a></p>

<h4>2.4 <span class="Heading">Garbage collection in <strong class="pkg">GAP</strong></span></h4>

<p><a id="X86E038D8796AECA3" name="X86E038D8796AECA3"></a></p>

<h5>2.4-1 <span class="Heading"><strong class="pkg">GASMAN</strong></span></h5>

<p><strong class="pkg">GASMAN</strong> is the <strong class="pkg">GAP</strong> memory manager. It provides an API dealing with <em>Bags</em> which are areas of memory, each with a size and a <code class="code">TNUM</code> (type number) in the range 0--253 (type numbers are defined in the file <code class="file">objects.h</code>; there are some spare numbers reserved for further extensions; types 254 and 255 are reserved for <strong class="pkg">GASMAN</strong>. See Section <a href="chap2_mj.html#X849901607E91AC92"><span class="RefLink">2.6</span></a> for more details).</p>

<p>Bags have stable handles (of <strong class="pkg">C</strong> type <code class="code">Bag</code>) and can be resized. When the heap is full, inaccessible bags are automatically reclaimed and live bags may be moved, but the handles don't change (handle is a pointer to a pointer to the actual data). Bag references from <strong class="pkg">C</strong> local variables are found automatically, and references from <strong class="pkg">C</strong> static and global variables must be declared. <strong class="pkg">GASMAN</strong> recovers unreachable bags automatically -- it knows that bags in <strong class="pkg">C</strong> local variables <em>are</em> reachable. From the point of GC technicalities, <strong class="pkg">GASMAN</strong> is generational, conservative, compacting (i.e. bags may move, but each has a permanent ID) and cooperative (i.e. it imposes certain rules on its users) memory manager.</p>

<p>To get the type of the bag with the identifier <code class="code">b</code>, call <code class="code">TNUM_BAG(b)</code>.</p>

<p>The application specifies the type of a bag when it allocates it with <code class="code">NewBag</code> and may later change it with <code class="code">RetypeBag</code> (see <code class="code">NewBag</code> and <code class="code">RetypeBag</code> in <code class="file">gasman.h</code>).</p>

<p><strong class="pkg">GASMAN</strong> needs to know the type of a bag so that it knows which function to call to mark all subbags of a given bag (see <code class="code">InitMarkFuncBags</code> below). Apart from that <strong class="pkg">GASMAN</strong> does not care at all about types.</p>

<p><a id="X7AA6E6517ED276FA" name="X7AA6E6517ED276FA"></a></p>

<h5>2.4-2 <span class="Heading"><strong class="pkg">GASMAN</strong> Interface</span></h5>

<p><code class="code">Bag</code> is a type definition of some sort of pointer. It may be used as</p>


<div class="example"><pre>

Bag bag = NewBag(type, size);

</pre></div>

<p>Creation of a new bag may cause garbage collection, and <strong class="pkg">GAP</strong> will fail if space cannot be allocated.</p>

<p>To reach the data in a bag, call</p>


<div class="example"><pre>

Bag *ptr = PTR_BAG(bag);

</pre></div>

<p>and keep in mind that the cost of such call is one indirection.</p>

<p>The <em>key rule</em> is that you must NOT hold onto this pointer during any event which might cause a garbage collection. A common hidden trap is to use</p>


<div class="example"><pre>

PTR_BAG(list)[1] = NewBag(t,s);

</pre></div>

<p>because the pointer may be evaluated before the right-hand side evaluation, and used after it. Instead of this, you should use</p>


<div class="example"><pre>

{
  Obj temp = NewBag(t,s);
  PTR_BAG(list)[1] = temp;
}

</pre></div>

<p>There is a second rule: after you assigned a bag identifier <code class="code">b</code> into a bag <code class="code">c</code> and before the next garbage collection, you must call <code class="code">CHANGED_BAG(c)</code>, unless you know that <code class="code">b</code> cannot be garbage collected (e.g. it is an object like <code class="keyw">true</code>), or <code class="code">c</code> is the most recently allocated bag of all.</p>

<p>Other functions are:</p>


<ul>
<li><p><code class="code">RetypeBag( bag, newtnum )</code> changes the type of the bag with identifier <code class="code">bag</code> to the new type <code class="code">newtnum</code>. The identifier, the size, and also the address of the data area of the bag do not change.</p>

</li>
<li><p><code class="code">ResizeBag( bag, newsize )</code> changes the size of the bag with identifier <code class="code">bag</code> to the new size <code class="code">newsize</code>. The identifier of the bag does not change, but the address of the data area of the bag may change. If the new size is less than the old size, <strong class="pkg">GASMAN</strong> throws away any data in the bag beyond the new size. If the new size is larger than the old size, it extends the bag. Note that <code class="code">ResizeBag</code> will perform a garbage collection if no free storage is available. During the garbage collection the addresses of the data areas of all bags may change. So you must not keep any pointers to or into the data areas of bags over calls to <code class="code">ResizeBag</code> (see <code class="code">PTR_BAG</code> in <code class="file">gasman.h</code>).</p>

</li>
<li><p><code class="code">InitMarkFuncBags( type, mark-func )</code>(optional) installs the function <code class="code">mark-func</code> as marking function for bags of type <code class="code">type</code>. The application <em>must</em> install a marking function for a type before it allocates any bag of that type.</p>

<p>A marking function returns nothing. It just takes a single argument of type <code class="code">Bag</code> and applies the function <code class="code">MarkBag</code> to each bag identifier that appears in the bag. During garbage collection marking functions are applied to each marked bag (i.e. to all bags that are assumed to be still live), to also mark their subbags. The ability to use the correct marking function is the only use that <strong class="pkg">GASMAN</strong> has for types.</p>

<p><code class="code">MarkBag(b)</code> marks the bag <code class="code">b</code> as live so that it is not thrown away during a garbage collection. It tests if <code class="code">bag</code> is a valid identifier of a bag in the young bags area. If it is not, then <code class="code">MarkBag</code> does nothing, so there is no harm in calling it for something that is not actually a bag identifier. It is important that <code class="code">MarkBag</code> should only be called from the marking functions installed with <code class="code">InitMarkFuncBags</code>.</p>

<p><code class="code">MarkBagWeakly</code> is an alternative to <code class="code">MarkBag</code>, intended to be used by the marking functions of weak pointer objects. A bag which is marked both weakly and strongly is treated as strongly marked. A bag which is only weakly marked will be recovered by garbage collection, but its identifier remains, marked in a way which can be detected by <code class="code">IsWeakDeadBag</code>. This should always be checked before copying or using such an identifier.</p>

<p><strong class="pkg">GASMAN</strong> already provides the following standard marking functions defined in <code class="file">gasman.c</code>:</p>


<ul>
<li><p><code class="code">MarkNoSubBags( bag )</code> is a marking function for types whose bags contain no identifier of other bags. It does nothing, as its name implies, and simply returns. For example, the bags for large integers contain only the digits and no identifiers of bags.</p>

</li>
<li><p><code class="code">MarkOneSubBags( bag )</code> is a marking function for types whose bags contain exactly one identifier of another bag as the first entry. It marks this subbag and returns. For example, bags for finite field elements contain exactly one bag identifier for the finite field the element belongs to.</p>

</li>
<li><p><code class="code">MarkTwoSubBags( bag )</code> is a marking function for types whose bags contain exactly two identifiers of other bags as the first and second entry such as the binary operations bags. It marks those subbags and returns. For example, bags for rational numbers contain exactly two bag identifiers for the numerator and the denominator.</p>

</li>
<li><p><code class="code">MarkAllSubBags( bag )</code> is the marking function for types whose bags contain only identifiers of other bags (for example, bags or lists contain only bag identifiers for the elements of the list or 0 if an entry has no assigned value). <code class="code">MarkAllSubBags</code> marks every entry of such a bag. Note that <code class="code">MarkAllSubBags</code> assumes that all identifiers are at offsets from the address of the data area of <code class="code">bag</code> that are divisible by <code class="code">sizeof(Bag)</code>. Also, since it does not do any harm to mark something which is not actually a bag identifier, one could use <code class="code">MarkAllSubBags</code> for all types as long as the identifiers in the data area are properly aligned as explained above (this would however slow down <code class="code">CollectBags</code>). By default, <strong class="pkg">GASMAN</strong> uses <code class="code">MarkAllSubBagsDefault</code> which does exactly this.</p>

</li>
</ul>
</li>
</ul>
<p><a id="X7C1EFEEB8071E0A2" name="X7C1EFEEB8071E0A2"></a></p>

<h5>2.4-3 <span class="Heading">The GASMAN Interface for Weak Pointer Objects</span></h5>

<p>The key support for weak pointers is in the files <code class="file">src/gasman.c</code> and <code class="file">src/gasman.h</code>. This document assumes familiarity with the rest of the operation of GASMAN. A kernel type (tnum) of bags which are intended to act as weak pointers to their subobjects must meet three conditions. Firstly, the marking function installed for that tnum must use <code class="code">MarkBagWeakly</code> for those subbags, rather than <code class="code">MarkBag</code>. Secondly, before any access to such a subbag, it must be checked with <code class="code">IsWeakDeadBag</code>. If that returns <code class="keyw">true</code>, then the subbag has evaporated in a recent garbage collection and must not be accessed. Typically the reference to it should be removed. Thirdly, a <em>sweeping function</em> must be installed for that tnum which copies the bag, removing all references to dead weakly held subbags.</p>

<p>The files <code class="file">src/weakptr.c</code> and <code class="file">src/weakptr.h</code> use this interface to support weak pointer objects. Other objects with weak behaviour could be implemented in a similar way.</p>

<p><a id="X815C2D007A090300" name="X815C2D007A090300"></a></p>

<h4>2.5 <span class="Heading">Interfaces</span></h4>

<p>The modules at the bottom of the picture from the section <a href="chap2_mj.html#X78D70F927B947A2C"><span class="RefLink">2.3</span></a> (<em>objects</em>, <em>gasman</em> and <em>system</em>), and white boxes (<em>arithmetic</em>, <em>lists</em>, <em>calls/operations</em>, <em>records</em>) provide interfaces intended for use in the kernel.</p>

<p>For example <code class="file">ariths.h</code> provides functions like <code class="code">SUM</code>, <code class="code">PROD</code>, <code class="code">AINV</code>, corresponding to the GAP operations <code class="code">+</code>, <code class="code">*</code> and unary <code class="code">-</code>. These functions can be applied to any values (objects) to perform an appropriate action. Note that there is some overhead in using these general functions, if you know what your arguments are, there may be faster ways.</p>

<p>Another interface provides <code class="code">ELM_LIST</code>, <code class="code">ASS_LIST</code>, <code class="code">LEN_LIST</code>, etc. as a general interface to any type of list.</p>

<p>Functions like these will even work for <strong class="pkg">GAP</strong>-level objects whose arithmetic or list operations are implemented by installed methods.</p>

<p>Adding a kernel function is easy if it stays in the region within the thick lines, i.e. it uses interfaces from white and yellow areas, which provide kernel equivalents to the basic GAP functionality.</p>

<p>For example, the following kernel function will return a list containing an object, its square and its cube:</p>


<div class="example"><pre>

/*  x -&gt; [x,x^2,x^3]  */
static Obj FuncFoo1(Obj self, Obj x)
{
    Obj x2, x3;
    Obj list = NEW_PLIST( T_PLIST, 3 );
    SET_ELM_PLIST( list, 1, x );
    CHANGED_BAG( list );

    x2 = PROD( x, x );
    SET_ELM_PLIST( list, 2, x2 );
    CHANGED_BAG( list );

    x3 = PROD( x2, x );
    SET_ELM_PLIST( list, 3, x3 );
    CHANGED_BAG( list );

    SET_LEN_PLIST(list, 3);
    return list;
}

</pre></div>

<p>If speed is not of utmost importance, then it is usually better to use the <code class="code">ASS_LIST</code> etc. functions instead of <code class="code">SET_ELM_PLIST</code> and friends, which are more low-level and easier to misuse. For example, they automatically call <code class="code">CHANGED_BAG</code> and <code class="code">SET_LEN_PLIST</code>. Then the above example would become this instead:</p>


<div class="example"><pre>

/*  x -&gt; [x,x^2,x^3]  */
static Obj FuncFoo2(Obj self, Obj x)
{
    Obj x2, x3;
    Obj list = NEW_PLIST( T_PLIST, 3 );
    ASS_LIST( list, 1, x );

    x2 = PROD( x, x );
    ASS_LIST( list, 2, x2 );

    x3 = PROD( x2, x );
    ASS_LIST( list, 3, x3 );

    return list;
}

</pre></div>

<p>Finally, if all you want to do is produce a list of fixed length, you can use the <code class="code">NewPlistFromArgs</code> helper function:</p>


<div class="example"><pre>

/*  x -&gt; [x,x^2,x^3]  */
Obj FuncFoo3(Obj self, Obj x)
{
    Obj x2 = PROD( x, x );
    Obj x3 = PROD( x2, x );
    return NewPlistFromArgs( x, x2, x3 );
}

</pre></div>

<p><a id="X849901607E91AC92" name="X849901607E91AC92"></a></p>

<h4>2.6 <span class="Heading">Objects and API</span></h4>

<p>The kernel representation of every <strong class="pkg">GAP</strong> object is an object of <strong class="pkg">C</strong> type <code class="code">Obj</code>. Objects are defined in the file <code class="file">objects.h</code>. Objects are actually <em>bags</em> (represented by their handles), small integers and small finite field elements (represented by values that could not be valid handles). <code class="code">Bag</code> is the type of bag identifiers, defined in the file <code class="file">system.h</code>:</p>


<div class="example"><pre>

typedef UInt * *        Bag;

</pre></div>

<p>Each bag is identified by its <em>bag identifier</em>, and no two live bags have the same identifier.</p>

<p>Note that the identifier of a bag is different from the address of the data area of the bag. This address may change during a garbage collection while the identifier of a bag never changes. Bags that contain references to other bags must always contain the identifiers of these other bags, never the addresses of the data areas of the bags.</p>

<p>Note that bag identifiers are recycled. That means that after a bag dies its identifier may be reused for a new bag.</p>

<p>0 is a valid value of the type <code class="code">Bag</code>, but is guaranteed not to be the identifier of any bag.</p>

<p>The ability to distinguish between bags and other objects relies on the fact that all bag identifiers are divisible by 4.</p>

<p>There are lots of kernel API functions providing a uniform interface for working with objects:</p>


<ul>
<li><p><code class="code">TNUM_OBJ</code> (first level type), <code class="code">SIZE_OBJ</code>, <code class="code">ADDR_OBJ</code> (C pointer to data), <code class="code">TYPE_OBJ</code> (full type)</p>

</li>
<li><p><code class="code">IS_MUTABLE_OBJ</code>, <code class="code">MakeImmutable</code>, <code class="code">COPY_OBJ</code>, ...</p>

</li>
<li><p><code class="code">PRINT_OBJ</code></p>

</li>
<li><p><code class="code">NEW_PLIST</code>, <code class="code">SET_ELM_PLIST</code>, etc. for creating plain lists</p>

</li>
<li><p><code class="code">PROD</code> for arithmetic (see also <code class="code">SUM</code>, <code class="code">DIFF</code>, etc.)</p>

</li>
</ul>
<p>These functions are flexible: for example, <code class="code">PROD</code> will multiply anything, but if you know what objects you will have it will be a bit faster to call the multiplication directly.</p>

<p>Typical implementation is a table of functions indexed by <code class="code">TNUM_OBJ</code>. For example, this is the definition of <code class="code">PROD</code> in the file <code class="file">ariths.h</code> (you can safely ignore the <code class="code">EXPORT_INLINE</code> for now):</p>


<div class="example"><pre>

EXPORT_INLINE Obj PROD(Obj opL, Obj opR)
{
    UInt tnumL = TNUM_OBJ(opL);
    UInt tnumR = TNUM_OBJ(opR);
    return (*ProdFuncs[tnumL][tnumR])(opL, opR);
}

</pre></div>

<p>Additionally, <code class="file">objects.h</code> also defines symbolic names for TNUMs.</p>

<p>There are lots of other API functions for strings, general lists, calling functions, etc.</p>

<p><a id="X7B314E837FD109B1" name="X7B314E837FD109B1"></a></p>

<h5>2.6-1 <span class="Heading">Immediate Integers and FFEs</span></h5>

<p>There are three integer types in GAP: <code class="code">T_INT</code>, <code class="code">T_INTPOS</code> and <code class="code">T_INTNEG</code>. Each integer has a unique representation, e.g., an integer that can be represented as <code class="code">T_INT</code> is never represented as <code class="code">T_INTPOS</code> or <code class="code">T_INTNEG</code>.</p>

<p><code class="code">T_INT</code> is the type of those integers small enough to fit into 29 bits (on 32 bit systems) respectively 61 bits (on 64 bit systems). Therefore the value range of this small integers is <span class="SimpleMath">\(-2^{28}...2^{28}-1\)</span> respectively <span class="SimpleMath">\(-2^{60}...2^{60}-1\)</span>. Only these small integers can be used as index expression into sequences.</p>

<p>Small integers are represented by an immediate integer handle, containing the value instead of pointing to it, which has the format <code class="code">ss&lt;28 data bits&gt;01</code> respectively <code class="code">ss&lt;60 data bits&gt;01</code>.</p>

<p>Immediate integers handles carry the tag <code class="code">T_INT</code>, i.e. the last bit is 1. Thus, the last bit distinguishes immediate integers from other handles which point to structures aligned on 4 byte (on 32 bit) respectively 8 byte (on 64 bit) boundaries and therefore have last bit zero. (The bit before the last is reserved as tag to allow extensions of this scheme.) Using immediates as pointers and dereferencing them gives address errors.</p>

<p>The first two bits <code class="code">ss</code> are two copies of the sign bit. That is, the sign bit of immediate integers has a guard bit, that allows quick detection of overflow for addition since these two bits must always be equal.</p>

<p>Functions <code class="code">IS_INTOBJ</code> and <code class="code">ARE_INTOBJS</code> are used to test if an object (or two objects) is an (immediate) integer object. The functions <code class="code">INTOBJ_INT</code> is used to convert a <strong class="pkg">C</strong> integer to an (immediate) integer object, and <code class="code">INT_INTOBJ</code> is used to convert the (immediate) integer object to a <strong class="pkg">C</strong> integer. These functions do NOT check for overflows.</p>

<p>The other two integer types are <code class="code">T_INTPOS</code> and <code class="code">T_INTNEG</code> for positive (respectively, negative) integer values that cannot be represented by immediate integers. See comments in <code class="file">integer.c</code> for details.</p>

<p>Other immediate objects are <em>finite field elements</em> (FFEs). The kernel supports small finite fields with up to 65536 elements (larger fields can be realized as polynomial domains over smaller fields). Immediate FFEs are represented in the format <code class="code">&lt;16 bit value&gt;&lt;13 bit field ID&gt;010</code>, where the least significant 3 bits of such an immediate object are always 010, flagging the object as an object of a small finite field.</p>

<p>The next 13 bits represent the small finite field where the element lies, and they are simply an index into a global table of small finite fields.</p>

<p>The most significant 16 bits represent the value of the element.</p>

<p>If the value is 0, then the element is the zero from the finite field. Otherwise the integer is the logarithm of this element with respect to a fixed generator of the multiplicative group of the finite field plus one. In the following descriptions we denote this generator always with <span class="SimpleMath">\(z\)</span>, it is an element of order <span class="SimpleMath">\(ord-1\)</span>, where <span class="SimpleMath">\(ord\)</span> is the order of the finite field. Thus 1 corresponds to <span class="SimpleMath">\(z^{1-1} = z^0 = 1\)</span>, i.e., the one from the field. Likewise 2 corresponds to <span class="SimpleMath">\(z^{2-1} = z^1 = z\)</span>, i.e., the root itself.</p>

<p>This representation makes multiplication very easy, we only have to add the values and subtract 1 , because <span class="SimpleMath">\(z^{a-1} * z^{b-1} = z^{(a+b-1)-1}\)</span>. Addition is reduced to multiplication by the formula <span class="SimpleMath">\(z^a + z^b = z^b * (z^{a-b}+1)\)</span>. This makes it necessary to know the successor <span class="SimpleMath">\(z^a + 1\)</span> of every value.</p>

<p>The finite field bag contains the successor for every nonzero value, i.e., <code class="code">SUCC_FF(&lt;ff&gt;)[&lt;a&gt;]</code> is the successor of the element <code class="code">&lt;a&gt;</code>, i.e, it is the logarithm of <span class="SimpleMath">\(z^{a-1} + 1\)</span>. This list is usually called the Zech-Logarithm table. The zeroth entry in the finite field bag is the order of the finite field minus one.</p>

<p><code class="code">T_INT</code> and <code class="code">T_FFE</code> are reserved <code class="code">TNUM</code>s for immediate integers and FFEs. <code class="code">TNUM_OBJ</code> produces them if needed and otherwise calls <code class="code">TNUM_BAG</code>.</p>

<p>The kernel design allows that other immediate types could be added in the future.</p>

<p><a id="X87FF26F4878230FB" name="X87FF26F4878230FB"></a></p>

<h5>2.6-2 <span class="Heading">Arithmetics</span></h5>

<p>Arithmetic operations package is implemented in files <code class="file">ariths.h</code> and <code class="file">ariths.c</code>. In particular, it defines functions like <code class="code">SUM(obj1, obj2)</code>, <code class="code">DIFF</code>, <code class="code">PROD</code> etc., which accept (and may return) objects of any kind, including immediate objects. Selection of the appropriate method is handled via calling <code class="code">TNUM_OBJ</code> for arguments and then calling the appropriate method from the table of functions, for example:</p>


<div class="example"><pre>

EXPORT_INLINE Obj SUM(Obj opL, Obj opR)
{
    UInt tnumL = TNUM_OBJ(opL);
    UInt tnumR = TNUM_OBJ(opR);
    return (*SumFuncs[tnumL][tnumR])(opL, opR);
}

</pre></div>

<p>The default entry of the table of functions just calls back to the <strong class="pkg">GAP</strong> level to look for the installed methods (see e.g. <code class="code">SumObject</code> in <code class="file">ariths.c</code>), but note that kernel methods installed in tables <em>OVERRIDE</em> <strong class="pkg">GAP</strong> installed methods.</p>

<p>If you expect to handle mainly small integers, then it is significantly faster to do:</p>


<div class="example"><pre>

if ( ! ARE_INTOBJS( &lt;opL&gt;, &lt;opR&gt; ) || ! SUM_INTOBJS( &lt;res&gt;, &lt;opL&gt;, &lt;opR&gt; ) )
    &lt;res&gt; = SUM( &lt;opL&gt;, &lt;opR&gt; );

</pre></div>

<p>instead of <code class="code">&lt;res&gt; = SUM(&lt;opL&gt;, &lt;opR&gt;)</code>, where <code class="code">SUM_INTOBJS</code> is a function, which returns 0 if the answer overflows and a large integer needs to be created.</p>

<p>Finally, note that lots of functions in <code class="file">ariths.h</code> called <code class="code">C_&lt;something&gt;</code> are used mainly by the compiler.</p>

<p><a id="X86FA580F8055B274" name="X86FA580F8055B274"></a></p>

<h5>2.6-3 <span class="Heading">Functions</span></h5>

<p>The function call mechanism package is implemented in files <code class="file">calls.h</code> and <code class="file">calls.c</code>. A function object in <strong class="pkg">GAP</strong> is represented by a bag of the type <code class="code">T_FUNCTION</code>. The bag for the function <code class="code">f</code> contains eight pointers fo <strong class="pkg">C</strong> functions - its handlers. These eight functions are for 0,1,2,...,6 arguments and X arguments respectively, and the <span class="SimpleMath">\(i\)</span>-th handler can be accessed using the function <code class="code">HDLR_FUNC(f, i)</code>. This is exactly what is done by functions <code class="code">CALL_0ARGS</code>, <code class="code">CALL_1ARGS</code>, ..., <code class="code">CALL_6ARGS</code> and <code class="code">CALL_XARGS</code>, which simply call the appropriate handlers, passing the function bag and the arguments. <code class="code">CALL_0ARGS</code> is for calls passing no arguments, <code class="code">CALL_1ARGS</code> is for calls passing one argument, and so on. Thus, the kernel equivalent of the GAP code <code class="code">r := f(a,b)</code> is <code class="code">r = CALL_2ARGS(f,a,b)</code>. <code class="code">CALL_XARGS</code> is for calls passing more than 6 arguments or for variadic functions, and it requires the arguments to be collected in a single plain list.</p>

<p>There is a range of standard handlers that deal with calls to regular <strong class="pkg">GAP</strong> functions, to operations, attributes and properties and that also deal with <strong class="pkg">GAP</strong> variadic functions given as <code class="code">function(arg)</code>.</p>

<p>For kernel functions, the handler is the actual function which does the work. A typical handler (for 1-argument function) looks like</p>


<div class="example"><pre>

Obj FuncLength(Obj self, Obj list)
{
    return INTOBJ_INT(LEN_LIST(list));
}

</pre></div>

<p>Often the handler has to do some checks on arguments as well. In the example above <code class="code">LEN_LIST</code> takes care of this (mainly because the jump table for <code class="code">LEN_LIST</code> contains error functions for non-lists). Every handler must be registered (once) with a unique "cookie" by calling <code class="code">InitHandlerFunc( handler, cookie )</code> before it is installed in any function bag. This is needed so that it can be identified when loading a saved workspace. <var class="Arg">cookie</var> should be a unique <strong class="pkg">C</strong> string, identifying the handler.</p>

<p>To create a function object, there are three functions <code class="code">NewFunction</code>, <code class="code">NewFunctionC</code>, and <code class="code">NewFunctionT</code>, defined in the file <code class="file">calls.c</code>.</p>

<p><code class="code">NewFunction( name, narg, nams, hdlr )</code> creates and returns a new function. <var class="Arg">name</var> must be a <strong class="pkg">GAP</strong> string containing the name of the function. <var class="Arg">narg</var> must be the number of arguments, where -1 indicates a variable number of arguments. <var class="Arg">nams</var> must be a <strong class="pkg">GAP</strong> list containing the names of the arguments. <var class="Arg">hdlr</var> must be the <strong class="pkg">C</strong> function (accepting <var class="Arg">self</var> and the <var class="Arg">narg</var> arguments) that will be called to execute the function.</p>

<p><code class="code">NewFunctionC</code> does the same as <code class="code">NewFunction</code>, but expects <var class="Arg">name</var> and <var class="Arg">nams</var> as <strong class="pkg">C</strong> strings. <code class="code">NewFunctionT</code> also does the same as <code class="code">NewFunction</code>, but has two extra arguments that allow to specify the <var class="Arg">type</var> and <var class="Arg">size</var> of the newly created bag.</p>

<p>For example, you can make a function object using the code like this:</p>


<div class="example"><pre>

lenfunc = NewFunctionC("Length", 1, "list", FuncLength);

</pre></div>

<p><a id="X7B256AE5780F140A" name="X7B256AE5780F140A"></a></p>

<h5>2.6-4 <span class="Heading">Lists</span></h5>

<p>The <strong class="pkg">GAP</strong> kernel provides a generic list interface, which is equivalent to using <code class="code">list[i]</code> etc. in the library. This interface works for all types of lists known to GAP, including virtual lists. It has functions like <code class="code">IS_LIST</code> (returns <strong class="pkg">C</strong> Boolean), <code class="code">LEN_LIST</code> (returns <strong class="pkg">C</strong> integer), <code class="code">ISB_LIST</code>, <code class="code">ELM_LIST</code>, <code class="code">ELM0_LIST( &lt;list&gt;, &lt;pos&gt; ) </code> (returns 0 if &lt;list&gt; has no assigned object at position &lt;pos&gt;) and <code class="code">ASS_LIST</code>, defined in the file <code class="file">lists.h</code> Implementation of these functions is done via tables of functions indexed by TNUM.</p>

<p>Nevertheless, it will be not much faster to write your <strong class="pkg">C</strong> code using such functions, for example, to reverse an arbitrary list, than to do the same working in <strong class="pkg">GAP</strong>. However, in case of <em>plain lists</em> coding in <strong class="pkg">C</strong> actually ought to produce some speedup.</p>

<p>A plain list is a list that may have holes and may contain elements of arbitrary types. A plain list may also have room for elements beyond its current logical length. The last position to which an element can be assigned without resizing the plain list is called the physical length.</p>

<p>If you need to create a plain list, use <code class="code">NEW_PLIST(&lt;tnum&gt;,&lt;plength&gt;)</code>, where <code class="code">&lt;tnum&gt;</code> should be <code class="code">T_PLIST_&lt;something&gt;</code>, and <code class="code">&lt;plength&gt;</code> is physical length in bags. Furthermore, <code class="code">LEN_PLIST</code> gets its logical length, and <code class="code">SET_LEN_PLIST</code> sets its logical length. Note that <code class="code">ELM_PLIST</code> is faster than <code class="code">ELM_LIST</code>.</p>

<p><a id="X789D77787E3527D4" name="X789D77787E3527D4"></a></p>

<h5>2.6-5 <span class="Heading">Data objects</span></h5>

<p><em>Positional</em> and <em>Component</em> objects are made from lists and records using <code class="code">Objectify</code>. They contain their <em>Type</em> and data accessible with <code class="code">![]</code> and <code class="code">!.</code> operations.</p>

<p><em>Data objects</em> also contain their <em>Type</em>, but the data is only accessible via kernel functions. Data can be anything you like <em>except</em> bag references. The garbage collector doesn't see inside them. At a minimum, construction and basic access functions need to be written in the kernel. For example, compressed vectors are done this way.</p>

<p><a id="X7A547AB487DA5FA9" name="X7A547AB487DA5FA9"></a></p>

<h4>2.7 <span class="Heading">Rules of Kernel Programming</span></h4>

<p><a id="X861B9EB587F6B238" name="X861B9EB587F6B238"></a></p>

<h5>2.7-1 <span class="Heading">Three golden rules</span></h5>

<p>Three golden rules of <strong class="pkg">GAP</strong> kernel programming:</p>

<ol>
<li><p>Real <strong class="pkg">C</strong> pointers into objects (returned by <code class="code">ADDR_OBJ</code>) must <em>not</em> be held across anything that could cause a garbage collection (<em>GC</em>).</p>

</li>
<li><p>If you add a new object to another one (e.g. put it in a list) you must call <code class="code">CHANGED_BAG</code> on the container, otherwise the new object may get lost in a GC.</p>

</li>
<li><p>Don't use malloc: actually using it a little bit is usually safe, and it's safe if you don't ever want to expand the GAP workspace.</p>

</li>
</ol>
<p><a id="X8055D4158291EAA2" name="X8055D4158291EAA2"></a></p>

<h5>2.7-2 <span class="Heading">Common kernel traps</span></h5>

<p>More things can cause a garbage collection than you expect:</p>


<ul>
<li><p>printing (might be to string stream)</p>

</li>
<li><p>generic list or record access (might be handled by <strong class="pkg">GAP</strong> methods)</p>

</li>
<li><p>integer arithmetic (might overflow to large integers)</p>

</li>
</ul>
<p>Be careful of things like</p>


<div class="example"><pre>

ELM_PLIST(l, 3) = something that might cause GC

</pre></div>

<p>This expands in <strong class="pkg">C</strong> to <code class="code">*((*l)+3) = something</code>. The compiler is allowed to follow the inner *, then evaluate the right-hand side, then the outer *. This will be broken by the garbage collection.</p>

<p><a id="X7FC1A0FA7B0E8554" name="X7FC1A0FA7B0E8554"></a></p>

<h5>2.7-3 <span class="Heading">One More Bit of GASMAN interface</span></h5>

<p>When you store a Bag ID in a <strong class="pkg">C</strong> global variable, you must declare the address of the global to <strong class="pkg">GASMAN</strong> (so the GC knows that the bag is alive). This is done by calling <code class="code">InitGlobalBag</code> passing the address and another "cookie" which is used by save/load.</p>

<p>There are nice ways to do all the global and handler initializations from tables.</p>

<p><a id="X82DBFB18873C8E8F" name="X82DBFB18873C8E8F"></a></p>

<h4>2.8 <span class="Heading">The <strong class="pkg">GAP</strong> compiler</span></h4>

<p><a id="X7AFA67497FA81DCD" name="X7AFA67497FA81DCD"></a></p>

<h5>2.8-1 <span class="Heading">Compiling <strong class="pkg">GAP</strong> Code</span></h5>

<p>The <strong class="pkg">GAP</strong> compiler converts <strong class="pkg">GAP</strong> code into kernel functions. The compiled code then can be loaded into a running kernel (on UNIX or Mac OS). The resulting code still has to do lots of checks, so usually it will not be as fast as hand-written <strong class="pkg">C</strong> program. The performance gain is significant for code that spends a lot of time in loops, small integer arithmetic, etc., and will be not significant if code spends most of its time in the kernel or elsewhere in library.</p>

<p>In the following example we compile the file <code class="file">foo.g</code> and then load it during the subsequent <strong class="pkg">GAP</strong> session:</p>


<div class="example"><pre>

$ cat &gt; foo.g
foo := x -&gt; [x,x^2,x^3];
$ gac -d -C foo.g
... compilation to C file ...
$ gac -d foo.g
... compilation to .so file ...
$ ls -l foo.so
-rwxr-xr-x 1 sal 158 4999 2007-09-11 10:19 foo.so*
$ gap -b
GAP4, Version: 4.dev of today, ....
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadDynamicModule("./foo.so");</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Print(foo);</span>
function ( x )
    &lt;&lt;compiled GAP code&gt;&gt; from foo.g:1
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">foo(3);</span>
[ 3, 9, 27 ]

</pre></div>

<p>The compiler code will look as follows:</p>


<div class="example"><pre>

/* return [ x, x ^ 2, x ^ 3 ]; */
t_1 = NEW_PLIST( T_PLIST, 3 );
SET_LEN_PLIST( t_1, 3 );
SET_ELM_PLIST( t_1, 1, a_x );
CHANGED_BAG( t_1 );
t_2 = POW( a_x, INTOBJ_INT(2) );
SET_ELM_PLIST( t_1, 2, t_2 );
CHANGED_BAG( t_1 );
t_2 = POW( a_x, INTOBJ_INT(3) );
SET_ELM_PLIST( t_1, 3, t_2 );
CHANGED_BAG( t_1 );
SWITCH_TO_OLD_FRAME(oldFrame);
return t_1;

</pre></div>

<p>Note that the original <strong class="pkg">GAP</strong> code (more or less) appears as comments.</p>

<p>If you want to see or modify the intermediate <strong class="pkg">C</strong> code, you can also instruct the compiler to produce only the <strong class="pkg">C</strong> files by using the option <code class="code">-C</code> instead of <code class="code">-d</code>.</p>

<p>There are some known problems with <strong class="pkg">C</strong> code produced with the <strong class="pkg">GAP</strong> compiler on 32 bit architectures and used on 64 bit architectures (and vice versa).</p>

<p>There are more ways to exploit the <strong class="pkg">GAP</strong> compiler apart from just compiling the <strong class="pkg">GAP</strong> code:</p>


<ul>
<li><p>You can compile your code and then hand-optimize critical sections. For example, you can replace calls to <code class="code">POW</code> by calls to <code class="code">PROD</code> or even to the product function for particular kinds of objects. You must be aware of a risk of a segmentation fault if you will call your function with wrong arguments.</p>

</li>
<li><p>You can use the compiler to generate a shell that can be dynamically loaded, and then fill in your own <strong class="pkg">C</strong> code in this shell. This approach is used in <strong class="pkg">Browse</strong>, <strong class="pkg">EDIM</strong> and <strong class="pkg">IO</strong> packages. In this case you must make it sure that your code complies with rules.</p>

</li>
</ul>
<p><a id="X7FBB45C17D3F3B0B" name="X7FBB45C17D3F3B0B"></a></p>

<h5>2.8-2 <span class="Heading">Suitability for Compilation</span></h5>

<p>Typically algorithms spend large parts of their runtime only in small parts of the code. The design of <strong class="pkg">GAP</strong> reflects this situation with kernel methods for many time critical calculations such as matrix or permutation arithmetic.</p>

<p>Compiling an algorithm whose time critical parts are already in the kernel of course will give disappointing results: Compilation will only speed up the parts that are not already in the kernel and if they make us a small part of the runtime, the overall gain is small.</p>

<p>Routines that benefit from compilation are those which do extensive operations with basic data types, such as lists or small integers.</p>

<p><a id="X844D3126800839DE" name="X844D3126800839DE"></a></p>

<h5>2.8-3 <span class="Heading">Compiling Library Code</span></h5>

<p>This subsection describes the mechanism used to make <strong class="pkg">GAP</strong> recognize compiled versions of library files. Note that there is no point in compiling the whole library as typically only few functions benefit from compilation as described in Section <a href="chap2_mj.html#X7FBB45C17D3F3B0B"><span class="RefLink">2.8-2</span></a>.</p>

<p>All library files that come with <strong class="pkg">GAP</strong> (not the files that belong to <strong class="pkg">GAP</strong> packages) are read using the internal function <code class="code">READ_GAP_ROOT</code>. This function then checks whether a compiled version of the file exists and if its CRC number (see <span class="RefLink">Reference: CrcFile</span>) matches the file. If it does, the compiled version is loaded. Otherwise the file is read. You can start <strong class="pkg">GAP</strong> with the <code class="code">-D -N</code> option to see information printed about this process.</p>

<p>To make <strong class="pkg">GAP</strong> find the compiled versions, they must be put in the <code class="file">bin/</code><var class="Arg">systemname</var><code class="file">/compiled</code> directory (<var class="Arg">systemname</var> is the name you gave for compilation, for example <code class="file">i386-ibm-linux-gcc2</code>). They have to be called according to the following scheme: Suppose the file is <code class="file">humpty/dumpty.gi</code> in the <strong class="pkg">GAP</strong> home directory. Then the compiled version will be <code class="file">bin/</code><var class="Arg">systemname</var><code class="file">/compiled/humpty/gi/dumpty.so</code>. That is, the directory hierarchy is mirrored under the <code class="file">compiled</code> directory. A further directory level is added for the suffix of the file, and the suffix of the compiled version of the file is set to <code class="code">.so</code> (as produced by the compiler).</p>

<p>For example we show how to compile the <code class="file">combinat.gi</code> file on a Linux machine. Suppose we are in the home directory of the gap distribution.</p>


<div class="example"><pre>
bin/i386-ibm-linux-gcc2/gac -d lib/combinat.gi
</pre></div>

<p>creates a file <code class="file">combinat.so</code>. We now put it in the right place, creating also the necessary directories:</p>


<div class="example"><pre>
mkdir bin/i386-ibm-linux-gcc2/compiled
mkdir bin/i386-ibm-linux-gcc2/compiled/lib
mkdir bin/i386-ibm-linux-gcc2/compiled/lib/gi
mv combinat.so bin/i386-ibm-linux-gcc2/compiled/lib/gi
</pre></div>

<p>If you now start <strong class="pkg">GAP</strong> and look, for example, at the function <code class="func">Binomial</code> (<span class="RefLink">Reference: Binomial</span>), defined in <code class="file">combinat.gi</code>, you see it is indeed compiled:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(GaussianCoefficient);</span>
function ( n, k, q )
    &lt;&lt;compiled GAP code&gt;&gt; from GAPROOT/lib/combinat.g:26
end
</pre></div>

<p>The command line option <code class="code">-M</code> disables the loading of compiled modules and always reads code from the library.</p>

<p><a id="X7D9044767BEB1523" name="X7D9044767BEB1523"></a></p>

<h4>2.9 <span class="Heading">Global Variables</span></h4>

<p><a id="X7D9044767BEB1523" name="X7D9044767BEB1523"></a></p>

<h5>2.9-1 <span class="Heading">Global variables</span></h5>

<p>The part of the kernel that manages global variables, i.e., the global namespace, is contained in the files <code class="file">gvars.h</code> and <code class="file">gvars.c</code>. Global variables have an internal form, of type <code class="code">GVar</code> (actually an index into a hash table). They may be obtained with <code class="code">GVar gv = GVarName(&lt;string&gt;);</code>. A global variable may be safely held on to across GC (but not across save/load workspace).</p>

<p>To manipulate with global variables, you may use <code class="code">AssGVar(gv, &lt;obj&gt;)</code> or <code class="code">ValGVar( gv )</code> (returns 0 if unbound, not an error), etc.</p>

<p><a id="X7A106F327F75851A" name="X7A106F327F75851A"></a></p>

<h5>2.9-2 <span class="Heading">Tracking global variables</span></h5>

<p>The <strong class="pkg">C</strong> code</p>


<div class="example"><pre>

Obj Stuff;
InitCopyGVar( "stuff", &amp;Stuff );

</pre></div>

<p>causes <code class="code">Stuff</code> to track the value of the global named "stuff". When the global is changed, the new value will be put in the <strong class="pkg">C</strong> variable.</p>

<p>A useful refinement is <code class="code">InitFopyGVar</code>. This does the same, provided that the value assigned is a function, otherwise the <strong class="pkg">C</strong> variable points to a function that prints a suitable error message.</p>

<p>These are usually set up during initialization of a kernel module.</p>

<p><a id="X7B6775AC8609D5AB" name="X7B6775AC8609D5AB"></a></p>

<h4>2.10 <span class="Heading">The Kernel Module Structure and interface</span></h4>

<p><a id="X82E5407283B16176" name="X82E5407283B16176"></a></p>

<h5>2.10-1 <span class="Heading">The Kernel Module Structure</span></h5>

<p>Apart from a very small amount of glue, all of the kernel (including compiled GAP code) is organised into modules.</p>

<p>Basically each module consists of one <code class="code">.c</code> file and one <code class="code">.h</code> file. The file <code class="file">gap.c</code> contains the variable <code class="code">InitFuncsBuiltinModules</code> which is initialized with a list of functions such as <code class="code">InitInfoInt</code>. Each such function, when called, returns a data structure describing a module, which typically looks as follows:</p>


<div class="example"><pre>

/****************************************************************************
**
*F  InitInfoInt() . . . . . . . . . . . . . . . . . . table of init functions
*/
static StructInitInfo module = {
    .type = MODULE_BUILTIN,
    .name = "integer",
    .initKernel = InitKernel,
    .initLibrary = InitLibrary,
};

</pre></div>

<p>The first part is just information, but the functions from <code class="code">initKernel</code> down are the key to the interface to kernel modules.</p>

<p><a id="X875A1DC186FEC3C5" name="X875A1DC186FEC3C5"></a></p>

<h5>2.10-2 <span class="Heading">The Kernel Module Interface</span></h5>

<p>The general rule is that if a 0 appears, the function is skipped; indeed, you may omit entries which are 0.</p>

<p>When GAP is starting up, it does the following:</p>


<ul>
<li><p>Calls the <code class="code">initKernel</code> functions of all those modules that have one. If any of them return non-zero then it aborts.</p>

</li>
<li><p>Then calls the <code class="code">initLibrary</code> functions likewise</p>

</li>
<li><p>Then the <code class="code">checkInit</code> functions</p>

</li>
</ul>
<p>The other three functions relate to save/load workspace:</p>


<ul>
<li><p><code class="code">preSave</code> functions are called before saving.</p>

</li>
<li><p><code class="code">postSave</code> functions (in the reverse order) after saving</p>

</li>
<li><p><code class="code">postRestore</code> functions are called after a workspace has been loaded to finish linking up the kernel and workspace.</p>

</li>
</ul>
<p><a id="X7FBC8CDB82C7A500" name="X7FBC8CDB82C7A500"></a></p>

<h5>2.10-3 <span class="Heading">Sequences of Events</span></h5>

<p>Normal GAP startup (no -L)</p>


<ul>
<li><p>All <code class="code">initKernel</code> methods called (abort on non-zero return)</p>

</li>
<li><p>All <code class="code">initLibrary</code> methods called (abort on non-zero return)</p>

</li>
<li><p>All <code class="code">checkInit</code> methods called (abort on non-zero return)</p>

</li>
<li><p><code class="code">init.g</code> read</p>

</li>
</ul>
<p>Startup loading a workspace</p>


<ul>
<li><p>All <code class="code">initKernel</code> methods called (abort on non-zero return)</p>

</li>
<li><p>Workspace loaded, global bags and handlers linked up</p>

</li>
<li><p>All <code class="code">postRestore</code> methods called (abort on non-zero return)</p>

</li>
<li><p>Enter the main loop</p>

</li>
</ul>
<p><a id="X80CAC88A7E9561E3" name="X80CAC88A7E9561E3"></a></p>

<h5>2.10-4 <span class="Heading">Saving a Workspace</span></h5>


<ul>
<li><p>All <code class="code">preSave</code> methods called (recover on non-zero return)</p>

</li>
<li><p>Full garbage collection</p>

</li>
<li><p>After this, workspace must be "clean" -- no non-objects stored where objects are expected (eg in plain lists)</p>

</li>
<li><p>Saved workspace file written</p>

</li>
<li><p>All <code class="code">postSave</code> methods called in reverse order</p>

</li>
</ul>
<p><a id="X809F94777E699351" name="X809F94777E699351"></a></p>

<h5>2.10-5 <span class="Heading">Excerpts from InitKernel from integer.c</span></h5>


<div class="example"><pre>

/****************************************************************************
**
*V  GVarFuncs . . . . . . . . . . . . . . . . . . list of functions to export
*/
static StructGVarFunc GVarFuncs [] = {

    GVAR_FUNC(QUO_INT, 2, "a, b"),
    GVAR_FUNC(ABS_INT, 1, "n"),
    . . .
    { 0 }
};

/****************************************************************************
**
*F  InitKernel( &lt;module&gt; )  . . . . . . . . initialise kernel data structures
*/
static Int InitKernel (
    StructInitInfo *    module )
{
    UInt                t1,  t2;

    /* init filters and functions                                          */
    InitHdlrFiltsFromTable( GVarFilts );
    InitHdlrFuncsFromTable( GVarFuncs );
    . . .

</pre></div>

<p><a id="X7EA36574819CE9AD" name="X7EA36574819CE9AD"></a></p>

<h5>2.10-6 <span class="Heading">Commentary</span></h5>


<ul>
<li><p>The items in the array of <code class="code">StructGVarFunc</code> objects define the GAP-callable global functions exported by the module</p>

</li>
<li><p><code class="code">InitHdlrFuncsFromTable</code> initializes all the handlers with the given cookies</p>

</li>
<li><p>In the <code class="code">initLibrary</code> function of the same model, we see this:</p>


<div class="example"><pre>

/****************************************************************************
**
*F  InitLibrary( &lt;module&gt; ) . . . . . . .  initialise library data structures
*/
static Int InitLibrary (
    StructInitInfo *    module )
{
    /* init filters and functions                                          */
    InitGVarFiltsFromTable( GVarFilts );
    InitGVarFuncsFromTable( GVarFuncs );
    . . .

</pre></div>

</li>
<li><p>This call <code class="code">InitGVarFuncsFromTable</code> creates the actual function objects (in the workspace) using <code class="code">NewFunctionC</code></p>

</li>
<li><p>It also installs these objects in global variables and makes those variables read-only</p>

</li>
</ul>
<p><a id="X802173687AD2C3FD" name="X802173687AD2C3FD"></a></p>

<h5>2.10-7 <span class="Heading">Other Similar Functions</span></h5>


<ul>
<li><p>There are other support functions for module initialization</p>

</li>
<li><p>Defined in <code class="file">gap.c</code></p>

</li>
<li><p><code class="code">InitHdlr&lt;xxxx&gt;FromTable</code> and <code class="code">InitGVar&lt;xxxx&gt;FromTable</code> exist for filters, attributes, properties and operations</p>

</li>
<li><p>Structure definitions are found in <code class="file">system.h</code></p>

</li>
</ul>
<p><a id="X781C432386ED9C00" name="X781C432386ED9C00"></a></p>

<h5>2.10-8 <span class="Heading">Importing from the Library</span></h5>


<ul>
<li><p>There are data structures (e.g. types) and functions (e.g. for method selection) that are used by the kernel, but easier written in GAP</p>

</li>
<li><p>These are mainly in <code class="code">.g</code> files</p>

</li>
<li><p>They are imported into the kernel using <code class="code">ImportGVarFromLibrary</code> and <code class="code">ImportFuncFromLibrary</code></p>

</li>
<li><p>These are basically just <code class="code">InitCopyGVar</code> and <code class="code">InitFopyGVar</code></p>

</li>
<li><p>They also make the GVars read-only and keep some records</p>

</li>
<li><p>At the end of <code class="code">read1.g</code> the GAP function <code class="code">ExportToKernelFinished</code> is called</p>

</li>
<li><p>This checks that all the imported GVars have actually been read.</p>

</li>
<li><p>Until this is done, some functionality may not be usable yet (e.g. <code class="code">TYPE_OBJ</code>).</p>

</li>
</ul>
<p><a id="X797D02CD7AC39FE6" name="X797D02CD7AC39FE6"></a></p>

<h5>2.10-9 <span class="Heading">InitKernel</span></h5>

<p>Typical things to do in <code class="code">initKernel</code> functions:</p>


<ul>
<li><p>Call <code class="code">InitHdlrFuncsFromTable</code></p>

</li>
<li><p>Install names for bag types in <code class="code">InfoBags</code></p>

</li>
<li><p>Install marking functions for bag types (needed for garbage collection)</p>

</li>
<li><p>Install functions in kernel tables for...</p>


<ul>
<li><p>Saving</p>

</li>
<li><p>Loading</p>

</li>
<li><p>Printing</p>

</li>
<li><p>Arithmetic operations</p>

</li>
<li><p>Type determination</p>

</li>
<li><p>Copying (and MakeImmutable)</p>

</li>
<li><p>List access, length, and associated functions</p>

</li>
</ul>
</li>
<li><p>Initialize GVar copies and fopies and imports</p>

</li>
<li><p>Add entries to various tables used by the list machinery</p>

</li>
<li><p>DO NOT create ANY bags in the workspace (they would be lost in a restore workspace)</p>

</li>
</ul>
<p><a id="X7FDA1F307BC45E44" name="X7FDA1F307BC45E44"></a></p>

<h5>2.10-10 <span class="Heading">initLibrary and postRestore</span></h5>


<ul>
<li><p>These functions can create or access structure in the workspace</p>

</li>
<li><p>Often <code class="code">initLibrary</code> also calls <code class="code">postRestore</code></p>

</li>
<li><p>Typical <code class="code">postRestore</code> activities:</p>


<ul>
<li><p>running <code class="code">GVarName</code> to get the numbers of global variables of interest</p>

</li>
<li><p>likewise <code class="code">RNamName</code> to get the numbers for record field names</p>

</li>
<li><p>getting the length of things like the list of GVars into kernel variables</p>

</li>
</ul>
</li>
<li><p>other <code class="code">InitLibrary</code> activities:</p>


<ul>
<li><p>Call <code class="code">InitGVarFuncsFromTable</code> and its friends, using the same tables that were passed to the <code class="code">InitHdlr</code> functions</p>

</li>
<li><p>Create any other global variables (not holding functions)</p>

</li>
<li><p>Create any special functions (eg ones that have handlers for several ariths)</p>

</li>
</ul>
</li>
<li><p>Allocate any scratch areas needed in the workspace</p>

</li>
</ul>

<div class="chlinkprevnextbot">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap1_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap3_mj.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
